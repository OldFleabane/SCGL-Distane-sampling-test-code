---
title: "SecondTryScGl"
author: "Jonathan Amegin"
date: "2024-08-16"
output: html_document
---

# SCGL Distance Sampling data analysis

A test project cleaning and analyzing the Distance Sampling data collected on the Sclerocactus glauca (SCGL) trip

End goals:

-   Plot the individual observations for each site on a coordinate grid
-   Mark the observations which overlap/were observed both going NS & EW.
-   Get a percent observational error to apply across the observed population.

Site names: 3 & 1= Picnic, 10= Bridgport, 12= Fram

```{r message=FALSE, warning=FALSE, include=FALSE}
# tidyverse contains both 'dyplr' and 'ggplot2'
library(tidyverse)
library(dplyr)
library(janitor)
library(ggrepel)

scgl_obs <- read_csv("data_raw/distanceSampling_1.csv")
scgl_trans_length <- read_csv("data_raw/transect_2.csv")

scgl_obs <- clean_names(scgl_obs)
```

```{r}
#used for looking at transect length
clean_length <- scgl_trans_length %>% 
  dplyr::select(GlobalID, `Transect Number`,`Transect Direction`,`Transect Length`)

joined_scgl <- left_join(scgl_obs, clean_length, join_by ("parent_global_id"=="GlobalID"), relationship = "many-to-one")
```

Raw data needs to be made into a coordinate-grid-friendly format. Each site needs to have the coordinates transformed based on the layout of the transects on the plot.

The shapefiles were downloaded and measured based on transect length and distance-between-transects data.

```{r}
scgl <- scgl_obs[!(is.na(scgl_obs$transect_meter_mark|scgl_obs$distance_to_group)),] %>% #filtering NA's and outliers. 
        filter(transect_meter_mark < 110, distance_to_group < 10) %>% 
        mutate( object_id = as.factor(object_id),
                site_name = as.factor(site_name),
                transect_number = as.factor(transect_number))

# making the 'direction to group' indicate if the 'distance to group' needs to be left/right of transect.              
scgl1 <- scgl %>% 
   mutate(
    transect_meter_mark = case_when( 
      transect_orientation == "EW" ~ transect_meter_mark * -1, 
      TRUE ~ transect_meter_mark),
    distance_to_group = case_when(
      direction_to_group == "-" ~ distance_to_group * -1, 
      TRUE ~ distance_to_group ) 
          )
           

# setting up the (X,Y) columns to then transform based on plot analysis
scgl1 <- scgl1 %>% 
  mutate( x = case_when(transect_orientation == "NS" ~ distance_to_group, transect_orientation == "EW" ~ transect_meter_mark), 
          y = case_when(transect_orientation == "EW" ~ distance_to_group, transect_orientation == "NS" ~ transect_meter_mark)) 
                
                

fram <- scgl1 %>% 
  filter(site_name == "12")

picnic <- scgl1 %>% 
  filter(site_name == "1"| site_name == "3")

bridge <- scgl1 %>% 
  filter(site_name == "10")



```

```{r test function eval=FALSE, include=FALSE}

#trying out a custom function
crossed <- function(a, b){ 
  temp <- a
for (i in which(temp$transect_orientation == "NS")){  #looping through every ns observation
  
  for (n in which(temp$transect_orientation == "EW")){ #looping against every ew observation
  
if(
  ( abs(temp[i,'x'] - temp[n,'x']) <= b ) & 
    abs(temp[i,'y'] - temp[n,'y']) <= b ){
    temp[i, 'plant_id'] <- temp[n, 'plant_id']
  }
  } 
}
}
```

```{r function for cross zone, eval=FALSE, include=FALSE}
# Use a 'forloop' to filter cactus in the range we need. 

three_meter <- function (site){
  
  temp_site <- filter(site, between(transect_meter_mark, 0, 0))
  
  for (i in  seq(from = 0, to = 100, by = 10)){
    temp_cross <- filter(temp_site, between( transect_meter_mark, i-3, i+3))
    temp_site <- rbind(temp_site, temp_cross)
  
  } 
  temp_site <- filter(temp_site, distance_to_group <= 3)
  
  temp_site
  
}


```

Fram coordinate transformations to match plot design

```{r fram transform}
#transforming Fram coordinates to accurately reflect plot design. 
fram_1 <- fram %>% 
  mutate( 
    x = case_when(transect_orientation == "NS" & transect_number == "1" ~ x - 10, 
                  transect_orientation == "NS" & transect_number == "2" ~ x - 20,
                  transect_orientation == "NS" & transect_number == "3" ~ x - 30,
                  transect_orientation == "EW" & transect_number == "5" ~ x - 10,
                  TRUE ~ x
                  ),
    y = case_when(transect_orientation == "EW" & transect_number == "1" ~ y + 10,
                  transect_orientation == "EW" & transect_number == "5" ~ y + 50,
                  transect_orientation == "EW" & transect_number == "7" ~ y + 70,
                  transect_orientation == "EW" & transect_number == "8" ~ y + 80,
                  transect_orientation == "EW" & transect_number == "9" ~ y + 90,
                  TRUE ~ y),
    )

#Fram NS lines read backwards making 0 = 100. 
fram_1 <- fram_1 %>% 
  mutate(
    y = case_when(transect_orientation =="NS" ~ ((y - 100)* -1),
                  TRUE ~ y) )

#transect start/stops for mapping
fram_lines <- tibble( x = c(-10, -20, -30, 0, -10, 0, 0, 0), 
                      y = c(0, 0, 0, 10, 50, 70, 80, 90), 
                      xend = c(-10, -20, -30, -33, -33, -60, -65, -39), 
                      yend = c(100, 100, 100, 10, 50, 70, 80, 90)
                    )


 fram_plot<-  ggplot( data = fram_1, mapping = aes(x = x, y = y)) +
  geom_point() +
  geom_segment(data = fram_lines, aes(x = x, y = y, xend = xend, yend = yend)) 

  
  fram_plot +
    geom_point(data = fram_1, aes( colour = transect_orientation))+
    coord_fixed(ratio = 1, xlim = c(-75, 10), ylim = c(0, 100))
```

Now the observations on the NS transects need to be compared to the observations on the EW to find the double-observations.

```{r fram dupes and plot}
fram_id <- mutate(fram_1, plant_id = c(1:nrow(fram_1)))
   

for (i in which(fram_id$transect_orientation == "NS")){  #looping through every ns observation
  

  for (n in which(fram_id$transect_orientation == "EW")){ #looping against every ew observation
  
if(
  ( abs(fram_id[i,'x'] - fram_id[n,'x']) <= 0.5 ) & 
    abs(fram_id[i,'y'] - fram_id[n,'y']) <= 0.5 ){
    fram_id[i, 'plant_id'] <- fram_id[n, 'plant_id']
  }
  } 
}

fram_plot1 <- fram_id %>% 
  filter( duplicated(plant_id)) %>% 
  ggplot( mapping = aes( x = x, y = y)) +
  geom_point(color = "blue",) +
  geom_point(data = fram_id, shape = 1, aes( color = transect_orientation) ) +
  geom_segment(data = fram_lines, aes(x = x, y = y, xend = xend, yend = yend)) +
  coord_fixed(ratio = 1, xlim = c(-75, 10), ylim = c(0, 100)) 
  

fram_plot1  


 # geom_text( data = fram_id, aes( label = plant_id), size = 3)  #use to find plant
  
```

```{r fram cross sectioned}

# Use a 'forloop' to filter cactus in the range we need. 

fram_crossed <- fram_id %>% filter( between(transect_meter_mark, 0, 0)  )

for( i in seq(from = 0, to = 100, by = 10)){
  
   output <- filter(fram_id, between(transect_meter_mark, i-3, i+3)  )
fram_crossed <- rbind(fram_crossed, output)
}
fram_crossed <- filter(fram_crossed, distance_to_group <= 3)

rm(output)


#should be the corrected number of observations. 
print( paste("Corrected number based on observational error from crossed observations =", nrow(fram_id) / (nrow(filter(fram_id, duplicated(plant_id))  ) / nrow(fram_crossed)) , sep = " ")) 


```

Actual seen cactus at Fram = 82.

Corrected number based on observational error from crossed observations = **184.5**


Need to apply observation correction to NS & EW separately and then get the average. 
```{r}
#  error comes from the number if plants were seen going NS AND EW divided by number if plants seen going NS OR EW 
#  within the 3 meter crossing zone
ob_error_fram <- (nrow(filter(fram_id, duplicated(plant_id))  ) / nrow(fram_crossed))

mean( c(n_distinct(which(fram_id$transect_orientation == "NS")) / ob_error_fram,
        n_distinct(which(fram_id$transect_orientation == "EW")) / ob_error_fram))
```
NEW Corrected number based on observational error from crossed observations = **92.25**

**Picnic**

```{r picnic transform and plot}

#describing the plot design
pic_lines <- tibble( x = c(-20, -30, -40, -20, -10, -10, 0), 
                     y = c(20, 10, 0, 20, 30, 40, 50), 
                     xend = c(-20, -30, -40, -90, -70, -70, -50),
                     yend = c(60, 76, 50, 20, 30, 40, 50),
                     label = c("1NS", "2NS", "3NS", "1EW", "2EW", "3EW", "4EW"))
                
 picnic_1 <-  picnic %>% 
   mutate( 
    x = case_when(transect_orientation == "NS" & transect_number == "1" ~ x - 20, 
                  transect_orientation == "NS" & transect_number == "2" ~ x - 30,
                  transect_orientation == "NS" & transect_number == "3" ~ x - 40,
                  transect_orientation == "EW" & transect_number == "1" ~ x - 20,
                  transect_orientation == "EW" & transect_number == "2" ~ x - 10,
                  transect_orientation == "EW" & transect_number == "3" ~ x - 10,
                  transect_orientation == "EW" & transect_number == "4" ~ x
                  ),
    y = case_when(transect_orientation == "NS" & transect_number == "1" ~ y + 20, 
                  transect_orientation == "NS" & transect_number == "2" ~ y + 10,
                  transect_orientation == "NS" & transect_number == "3" ~ y ,
                  transect_orientation == "EW" & transect_number == "1" ~ y + 20,
                  transect_orientation == "EW" & transect_number == "2" ~ y + 30,
                  transect_orientation == "EW" & transect_number == "3" ~ y + 40,
                  transect_orientation == "EW" & transect_number == "4" ~ y + 50,
                  )
   )



picnic_id <- mutate(picnic_1, plant_id = c(1:nrow(picnic_1)))
   

for (i in which(picnic_id$transect_orientation == "NS")){  #looping through every ns observation
  
  for (n in which(picnic_id$transect_orientation == "EW")){ #looping against every ew observation
  
if(
  ( abs(picnic_id[i,'x'] - picnic_id[n,'x']) <= 0.5 ) & 
    abs(picnic_id[i,'y'] - picnic_id[n,'y']) <= 0.5 ){
    picnic_id[i, 'plant_id'] <- picnic_id[n, 'plant_id']
  }
  } 
}



pic_plot<-  picnic_id %>% 
  ggplot( mapping = aes(x = x, y = y)) +
  geom_point(aes(color = transect_orientation), shape = 1) +
  geom_segment(data = pic_lines, aes(x = x, y = y, xend = xend, yend = yend))
     
pic_plot1 <- pic_plot + 
  geom_point(data = filter(picnic_id, duplicated(plant_id))) +
  geom_text_repel(data = pic_lines,
            aes( label = label),
            size = 3,
            )



```

```{r picnic crossed sectioned}
pic_crossed <- picnic_id %>% filter( between(transect_meter_mark, 0, 0)  )

for( i in seq(from = 0, to = 100, by = 10)){
  
   output <- filter(picnic_id, between(transect_meter_mark, i-3, i+3)  )
pic_crossed <- rbind(pic_crossed, output)
}
pic_crossed <- filter(pic_crossed, distance_to_group <= 3)

rm(output)


#should be the corrected number of observations. 
print( paste("Corrected number based on observational error from crossed observations =", nrow(picnic_id) / (nrow(filter(picnic_id, duplicated(plant_id))  ) / nrow(pic_crossed)) , sep = " ")) 
```

Actual number of cactus seen at Picnic: **224**

Picnic corrected number based on observational error from crossed observations = **1306.66666666667**


```{r}
ob_error_pic <- (nrow(filter(picnic_id, duplicated(plant_id))  ) / nrow(pic_crossed))

mean( c(n_distinct(which(picnic_id$transect_orientation == "NS")) / ob_error_pic,
        n_distinct(which(picnic_id$transect_orientation == "EW")) / ob_error_pic))
```
NEW Picnic corrected number based on observational error from crossed observations = **653.3333**


------------------------------------------------------------------------

*Bridgeport. Having issues with the shape file matching the transect lengths recorded. Might need to reevaluate or scrap.*

```{r bridge eval=FALSE, include=FALSE}
#Describing Bridgeport design
bridge_lines <- tibble(x =
                        y = 
                         xend =
                         yend =)

#transforming Bridgeport points to match design
 bridge_1 <-  bridge %>% 
   mutate( 
    x = case_when(transect_orientation == "NS" & transect_number == "1" ~ x - 20, 
                  transect_orientation == "NS" & transect_number == "2" ~ x - 30,
                  transect_orientation == "NS" & transect_number == "3" ~ x - 40,
                  transect_orientation == "EW" & transect_number == "1" ~ x - 20,
                  transect_orientation == "EW" & transect_number == "2" ~ x - 10,
                  transect_orientation == "EW" & transect_number == "3" ~ x - 10,
                  transect_orientation == "EW" & transect_number == "4" ~ x
                  ),
    y = case_when(transect_orientation == "NS" & transect_number == "1" ~ y + 20, 
                  transect_orientation == "NS" & transect_number == "2" ~ y + 10,
                  transect_orientation == "NS" & transect_number == "3" ~ y ,
                  transect_orientation == "EW" & transect_number == "1" ~ y + 20,
                  transect_orientation == "EW" & transect_number == "2" ~ y + 30,
                  transect_orientation == "EW" & transect_number == "3" ~ y + 40,
                  transect_orientation == "EW" & transect_number == "4" ~ y + 50,
                  )
   )

 
b_lengths <- joined_scgl %>%
  filter(site_name == "10")

```


## NS vs EW
```{r}
compare_scgl <- tibble( counts = c("NS_count", "EW_count", "NS_EW", "cross_count"), 
                        fram = c(nrow(filter(fram_id, transect_orientation == "NS")), 
                                 nrow(filter(fram_id, transect_orientation == "EW")),
                                 nrow(fram_id),
                                 ((nrow(fram_id))/ (nrow(filter(fram_id, duplicated(plant_id))  ) / nrow(fram_crossed)))
                        ),
                        picnic = c(nrow(filter(picnic_id, transect_orientation == "NS")), 
                                 nrow(filter(picnic_id, transect_orientation == "EW")),
                                 nrow(picnic_id),
                                 ((nrow(picnic_id))/ (nrow(filter(picnic_id, duplicated(plant_id))  ) / nrow(pic_crossed)))
                        )
)
                                 
  compare_scgl <- pivot_longer(compare_scgl, cols = c(fram, picnic), names_to = "site")                               
   
  compare_scgl <- compare_scgl %>% 
  add_row(counts = "group total", site = "fram", value = sum(fram_group$group_total)) %>% 
  add_row(counts = "group total", site = "picnic", value = sum(pic_group$group_total))                              
                       
nrow(filter(picnic_id, transect_orientation == "NS")) / nrow(picnic_id)
nrow(filter(picnic_id, transect_orientation == "EW"))/ nrow(picnic_id)

nrow(filter(fram_id, transect_orientation == "NS")) / nrow(fram_id)
nrow(filter(fram_id, transect_orientation == "EW"))/ nrow(fram_id)


compare_plot <- compare_scgl %>% 
  ggplot( mapping = aes(site, value)) +
  geom_col(aes(color = counts), position = "dodge") +
  geom_text(label = compare_scgl$value) +
  labs(title = "Comparisons of count calculations") 
  

  compare_plot

  
```
Possible that large difference in the picnic orientation counts due to large grouping being counted as individuals in one direction and as groups in the other. 
```{r}
compare_scgl %>% 
  add_row(counts = "EW group total", site = "picnic", value = sum(select(filter(pic_group, transect_orientation == "EW"), group_total))) %>%
  add_row(counts = "NS group total", site = "picnic", value = sum(select(filter(pic_group, transect_orientation == "NS"), group_total)))  %>%   ggplot( mapping = aes(site, value)) +
  geom_col(aes(color = counts), position = "dodge") +
  labs(title = "Comparisons of count calculations") 
  
                       


```




```{r}

pic_group <- picnic_id %>% 
  mutate( group_total = rowSums(across(starts_with("number")), na.rm = TRUE))



pic_group %>% 
  ggplot( mapping = aes(x = x, y = y)) +
  geom_point(data = pic_group, shape = (pic_group$group_total + 48), aes(color = pic_group$transect_orientation), size = 3) +
  geom_segment(data = pic_lines, aes(x = x, y = y, xend = xend, yend = yend)) + 
  geom_point(data = filter(picnic_id, duplicated(plant_id)), shape = 0) +
  geom_text_repel(data = pic_lines,
            aes( label = label),
            size = 3
            )
               


fram_group <- fram_id %>% 
  mutate( group_total = rowSums(across(starts_with("number")), na.rm = TRUE))



fram_group %>% 
  ggplot( mapping = aes(x = x, y = y)) +
  geom_point(data = fram_group, shape = (fram_group$group_total + 48), aes(color = fram_group$transect_orientation), size = 3) +
  geom_segment(data = fram_lines, aes(x = x, y = y, xend = xend, yend = yend)) + 
  geom_point(data = filter(fram_group, duplicated(plant_id)), shape = 0) 
  

```



Checking the coordinates for the Picnic EW observations to ensure that they are all distinct individuals and not mistaken groups. 
```{r}
picnic_EW_check <- mutate(picnic_id, ew_id = c(1:nrow(picnic_id)))
   

for (i in which(picnic_EW_check$transect_orientation == "EW")){  #looping through every EW observation
  
if(
  ( abs(picnic_EW_check[i,'x'] - picnic_EW_check[i+1,'x']) <= .1 ) & 
  ( abs(picnic_EW_check[i,'y'] - picnic_EW_check[i+1,'y']) <= .1 )){
    picnic_EW_check[i, 'ew_id'] <- picnic_EW_check[n, 'ew_id']
  }
}
```

------------------------------------------------------------------------

Notes:

May try filtering all observations to be within 3 meters at the crossings before looking for duplicates to make sure the logic is correct.

Large clustering at Picnic, need to go through raw data and look for possible errors.

Having accurate shapefiles or descriptions of plot design is key.
