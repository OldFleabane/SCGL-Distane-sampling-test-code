---
title: "Final 2024 SCGL Distance Script"
author: "Jonathan Amegin"
date: "2024-09-24"
output: html_document
---

# [Sclerocactus Distance Sampling]{.underline}

End goals:

-   Plot the individual observations for each site on a coordinate grid
-   Mark the observations which overlap/were observed both going NS & EW.
-   Get a percent observational error to apply across the observed population.

Site names: 3 & 1= Picnic, 10= Bridgport, 12= Fram

## Setting Up

```{r message=FALSE, warning=FALSE, include=FALSE}
# tidyverse contains both 'dyplr' and 'ggplot2'
library(tidyverse)
library(dplyr)
library(janitor)
library(ggrepel)

scgl_obs <- read_csv("data_raw/distanceSampling_1.csv")
scgl_trans_length <- read_csv("data_raw/transect_2.csv")

scgl_obs <- clean_names(scgl_obs)
```

This function will be used later to find duplicate plants

```{r test function}

#trying out a custom function
crossed <- function(a, b){ 
  temp <- a
for (i in which(temp$transect_orientation == "NS")){  #looping through every ns observation
  
  for (n in which(temp$transect_orientation == "EW")){ #looping against every ew observation
  
if(
  ( abs(temp[i,'x'] - temp[n,'x']) <= b ) & 
    abs(temp[i,'y'] - temp[n,'y']) <= b ){
    temp[i, 'plant_id'] <- temp[n, 'plant_id']
  }
  } 
  }
  temp
}

```

```{r}
scgl <- scgl_obs[!(is.na(scgl_obs$transect_meter_mark|scgl_obs$distance_to_group)),] %>% #filtering NA's and outliers. 
        filter(transect_meter_mark < 110, distance_to_group < 10) %>% 
        mutate( object_id = as.factor(object_id),
                site_name = as.factor(site_name),
                transect_number = as.factor(transect_number))

# making the 'direction to group' indicate if the 'distance to group' needs to be left/right of transect.              
scgl1 <- scgl %>% 
   mutate(
    transect_meter_mark = case_when( 
      transect_orientation == "EW" ~ transect_meter_mark * -1, 
      TRUE ~ transect_meter_mark),
    distance_to_group = case_when(
      direction_to_group == "-" ~ distance_to_group * -1, 
      TRUE ~ distance_to_group ) 
          )
           

# setting up the (X,Y) columns to then transform based on plot analysis
scgl1 <- scgl1 %>% 
  mutate( x = case_when(transect_orientation == "NS" ~ distance_to_group, transect_orientation == "EW" ~ transect_meter_mark), 
          y = case_when(transect_orientation == "EW" ~ distance_to_group, transect_orientation == "NS" ~ transect_meter_mark)) 
                
                
#filtering to site
fram <- scgl1 %>% 
  filter(site_name == "12")

picnic <- scgl1 %>% 
  filter(site_name == "1"| site_name == "3")

bridge <- scgl1 %>% 
  filter(site_name == "10")

```

The raw data needs to be made into a coordinate-grid-friendly format. Each site needs to have the coordinates transformed based on the layout of the transects on the plot.These layouts were recorded via shapefile, so the shapefile was measured and compared to recorded information to figure out the necessary transformations to the data.

## Site 12: Fram

### Plotting individuals

Involves transforming the coordinates to match the plot design.

```{r fram transform}
#transforming Fram coordinates to accurately reflect plot design. 
fram_1 <- fram %>% 
  mutate( 
    x = case_when(transect_orientation == "NS" & transect_number == "1" ~ x - 10, 
                  transect_orientation == "NS" & transect_number == "2" ~ x - 20,
                  transect_orientation == "NS" & transect_number == "3" ~ x - 30,
                  transect_orientation == "EW" & transect_number == "5" ~ x - 10,
                  TRUE ~ x
                  ),
    y = case_when(transect_orientation == "EW" & transect_number == "1" ~ y + 10,
                  transect_orientation == "EW" & transect_number == "5" ~ y + 50,
                  transect_orientation == "EW" & transect_number == "7" ~ y + 70,
                  transect_orientation == "EW" & transect_number == "8" ~ y + 80,
                  transect_orientation == "EW" & transect_number == "9" ~ y + 90,
                  TRUE ~ y),
    )

#Fram NS lines read backwards making 0 = 100. 
fram_1 <- fram_1 %>% 
  mutate(
    y = case_when(transect_orientation =="NS" ~ ((y - 100)* -1),
                  TRUE ~ y) )

#transect start/stops for mapping
fram_lines <- tibble( x = c(-10, -20, -30, 0, -10, 0, 0, 0), 
                      y = c(0, 0, 0, 10, 50, 70, 80, 90), 
                      xend = c(-10, -20, -30, -33, -33, -60, -65, -39), 
                      yend = c(100, 100, 100, 10, 50, 70, 80, 90)
                    )


 fram_plot<-  ggplot( data = fram_1, mapping = aes(x = x, y = y)) +
  geom_point() +
  geom_segment(data = fram_lines, aes(x = x, y = y, xend = xend, yend = yend)) 

  
  fram_plot +
    geom_point(data = fram_1, aes( colour = transect_orientation))+
    coord_fixed(ratio = 1, xlim = c(-75, 10), ylim = c(0, 100))
```

### Marking Overlap

For the initial marking of overlapping points we will use a **fuzziness of 0.5cm.**

```{r fram dupes and plot}
fram_id <- mutate(fram_1, plant_id = c(1:nrow(fram_1)))
   
fram_id <- crossed(fram_id, .5)  # a = plot data w/ID's, b = fuzziness

fram_plot1 <- fram_id %>% 
  filter( duplicated(plant_id)) %>% 
  ggplot( mapping = aes( x = x, y = y)) +
  geom_point(color = "blue",) +
  geom_point(data = fram_id, shape = 1, aes( color = transect_orientation) ) +
  geom_segment(data = fram_lines, aes(x = x, y = y, xend = xend, yend = yend)) +
  coord_fixed(ratio = 1, xlim = c(-75, 10), ylim = c(0, 100)) 
  
 # geom_text( data = fram_id, aes( label = plant_id), size = 3)  
 # Use this add-on to display plant ID's alongside points

fram_plot1  



  
```

Dark blue points are overlapping observations based on fuzziness provided in the `crossed()` function

### Observational Error

Use a loop to filter down to only cactus that *should* have been seen both going EW & NS. The Observational Error calculated will be applied separately to NS & EW actual observations and then averaged together. This is meant to avoid double counting of overlapping observations.

```{r fram cross sectioned}

# Use a 'forloop' to filter cactus in the range we need. 
fram_crossed <- fram_id %>% filter( between(transect_meter_mark, 0, 0)  )
fram_crossed_ns <- fram_id %>% filter( between(transect_meter_mark, 0, 0)  )
fram_crossed_ew <- fram_id %>% filter( between(transect_meter_mark, 0, 0)  )

for( i in c(10, 50, 70, 80, 90)){
  
   output <- filter(fram_id, between(y, i-3, i+3) &  transect_orientation == "NS")
    fram_crossed_ns <- rbind(fram_crossed_ns, output)
}
    
for( i in c(-10, -20, -30)){
  
   output <- filter(fram_id, between(x, i-3, i+3) &  transect_orientation == "EW")
    fram_crossed_ew <- rbind(fram_crossed_ew, output)
}

    fram_crossed <- fram_crossed%>% 
      rbind(fram_crossed_ew) %>%
      rbind(fram_crossed_ns) %>% 
      filter(abs(distance_to_group) <= 3)
    

rm(output)


#Because the lines were not evenly placed, the observations need to be filter again to only the actual crossed zones


#  error comes from the number if plants were seen going NS AND EW divided by number if plants seen going NS OR EW within the 3 meter crossing zone

ob_error_fram <- (nrow(filter(fram_id, duplicated(plant_id))) / nrow(fram_crossed))
```

```{r echo=FALSE}
print(paste("Observational error =", ob_error_fram, sep = " "))
print(paste("Actual number of unique cactus = ", n_distinct(fram_id$plant_id), sep = " " ))
#should be the corrected number of observations. 
print( paste("Corrected number of observations =", 
             mean( c(n_distinct(which(fram_id$transect_orientation == "NS")) /           ob_error_fram, n_distinct(which(fram_id$transect_orientation == "EW")) /           ob_error_fram)) , sep = " ")) 


```

### Changing fuzziness

```{r}

#make a curve that shows how the number of corrected observations changes as you change the fuzziness
start<- Sys.time()
fram_fuzz <- tibble( fuzziness = c(seq(0.0, 3, by = 0.1)))
 fram_fuzz <-  fram_fuzz %>% 
    mutate( error = numeric(nrow(fram_fuzz)), 
            n_duplicated = numeric(nrow(fram_fuzz)),
            n_actual = numeric(nrow(fram_fuzz)), 
            n_corrected = numeric(nrow(fram_fuzz))
    )
    



for (fuzz in fram_fuzz$fuzziness){
  
fram_crazy <- mutate(fram_1, plant_id = c(1:nrow(fram_1)))

for (i in which(fram_crazy$transect_orientation == "NS")){  #looping through every ns observation
  

  for (n in which(fram_crazy$transect_orientation == "EW")){ #looping against every ew observation
  
if(
  ( abs(fram_crazy[i,'x'] - fram_crazy[n,'x']) <= fuzz ) & 
    abs(fram_crazy[i,'y'] - fram_crazy[n,'y']) <= fuzz ){
    fram_crazy[i, 'plant_id'] <- fram_crazy[n, 'plant_id']
  }
  } 
} 


fram_fuzz <- fram_fuzz %>% 
  mutate( error = ifelse(fuzziness == fuzz, (nrow(filter(fram_crazy, duplicated(plant_id))) / nrow(fram_crossed)), error),
          n_duplicated = ifelse(fuzziness == fuzz, sum(duplicated(fram_crazy$plant_id)), n_duplicated),
          n_actual = ifelse(fuzziness == fuzz, n_distinct(fram_crazy$plant_id), n_actual)
  ) 

fram_fuzz <- fram_fuzz %>% 
  mutate( n_corrected = ifelse(fuzziness == fuzz, mean( c(n_distinct(which(fram_crazy$transect_orientation == "NS"))/with(fram_fuzz, error[ fuzziness == fuzz] ), n_distinct(which(fram_crazy$transect_orientation == "EW"))/with(fram_fuzz, error[ fuzziness == fuzz] ))), n_corrected))

}
 stop <- Sys.time()
 stop - start
 
```

```{r}
  
pivot_longer(fram_fuzz, cols = !fuzziness, names_to= "type", values_to= "count") %>% 
  group_by(type) %>% 
  ggplot( aes(fuzziness, count, color = type))+
  geom_line() +
  labs( x = "Fuzziness (m)")

  


```

This chart shows the change in the calculated number of *overlapping*, *unique*, and *corrected* total observations as the fuzziness is increased from 0m to 3m.

## Picnic

### Plotting individuals

Involves transforming the coordinates to match the plot design.

```{r picnic transform and plot}

#describing the plot design
pic_lines <- tibble( x = c(-20, -30, -40, -20, -10, -10, 0), 
                     y = c(20, 10, 0, 20, 30, 40, 50), 
                     xend = c(-20, -30, -40, -90, -70, -70, -50),
                     yend = c(60, 76, 50, 20, 30, 40, 50),
                     label = c("1NS", "2NS", "3NS", "1EW", "2EW", "3EW", "4EW"))
                
 picnic_1 <-  picnic %>% 
   mutate( 
    x = case_when(transect_orientation == "NS" & transect_number == "1" ~ x - 20, 
                  transect_orientation == "NS" & transect_number == "2" ~ x - 30,
                  transect_orientation == "NS" & transect_number == "3" ~ x - 40,
                  transect_orientation == "EW" & transect_number == "1" ~ x - 20,
                  transect_orientation == "EW" & transect_number == "2" ~ x - 10,
                  transect_orientation == "EW" & transect_number == "3" ~ x - 10,
                  transect_orientation == "EW" & transect_number == "4" ~ x
                  ),
    y = case_when(transect_orientation == "NS" & transect_number == "1" ~ y + 20, 
                  transect_orientation == "NS" & transect_number == "2" ~ y + 10,
                  transect_orientation == "NS" & transect_number == "3" ~ y ,
                  transect_orientation == "EW" & transect_number == "1" ~ y + 20,
                  transect_orientation == "EW" & transect_number == "2" ~ y + 30,
                  transect_orientation == "EW" & transect_number == "3" ~ y + 40,
                  transect_orientation == "EW" & transect_number == "4" ~ y + 50,
                  )
   )
 
pic_plot <-  picnic_1 %>% 
  ggplot( mapping = aes(x = x, y = y)) +
  geom_point(aes(color = transect_orientation), shape = 1) +
  geom_segment(data = pic_lines, aes(x = x, y = y, xend = xend, yend = yend))
pic_plot

```

### Marking Overlap

```{r}
picnic_id <- mutate(picnic_1, plant_id = c(1:nrow(picnic_1)))

picnic_id <- crossed(picnic_id, 0.5)

pic_plot1 <- pic_plot + 
  geom_point(data = filter(picnic_id, duplicated(plant_id))) +
  geom_text_repel(data = pic_lines,
            aes( label = label),
            size = 3,
            )
pic_plot1

```

### Observational Error

```{r}
# Use a 'forloop' to filter cactus in the range we need. 
picnic_crossed <- picnic_id %>% filter( between(transect_meter_mark, 0, 0)  )
picnic_crossed_ns <- picnic_id %>% filter( between(transect_meter_mark, 0, 0)  )
picnic_crossed_ew <- picnic_id %>% filter( between(transect_meter_mark, 0, 0)  )

for( i in c(20, 30, 40, 50)){
  
   output <- filter(picnic_id, between(y, i-3, i+3) &  transect_orientation == "NS")
    picnic_crossed_ns <- rbind(picnic_crossed_ns, output)
}
    
for( i in c(-20, -30, -40)){
  
   output <- filter(picnic_id, between(x, i-3, i+3) &  transect_orientation == "EW")
    picnic_crossed_ew <- rbind(picnic_crossed_ew, output)
}

    picnic_crossed <- picnic_crossed%>% 
      rbind(picnic_crossed_ew) %>%
      rbind(picnic_crossed_ns) %>% 
      filter(abs(distance_to_group) <= 3)
    

rm(output)

ob_error_picnic <- (nrow(filter(picnic_id, duplicated(plant_id))) / nrow(picnic_crossed))


picnic_crossed %>%
  ggplot( mapping = aes(x = x, y = y)) +
  geom_point(aes(color = transect_orientation), shape = 1) +
  geom_segment(data = pic_lines, aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_point(data = filter(picnic_crossed, duplicated(plant_id))) +
  geom_text_repel(data = pic_lines,
            aes( label = label),
            size = 3,)
```

```{r echo=FALSE}

print(paste("Observational error =", ob_error_picnic, sep = " "))
print(paste("Actual number of unique cactus = ", n_distinct(picnic_id$plant_id), sep = " " ))
#should be the corrected number of observations. 
print( paste("Corrected number of observations =", 
             mean( c(n_distinct(which(picnic_id$transect_orientation == "NS")) /           ob_error_picnic, n_distinct(which(picnic_id$transect_orientation == "EW")) /           ob_error_picnic)) , sep = " ")) 

```

### Changing Fuziness

```{r}
start <- Sys.time()
#make a curve that shows how the number of corrected observations changes as you change the fuzziness

fuzziness <- c(seq(0, 3, by = 0.2))
 
      error = fuzziness
      n_duplicated = fuzziness
      n_actual = fuzziness 
      n_corrected = fuzziness



for (fuzz in fuzziness){
  
picnic_crazy <- mutate(picnic_1, plant_id = c(1:nrow(picnic_1)))

for (i in which(picnic_crazy$transect_orientation == "NS")){  #looping through every ns observation
  

  for (n in which(picnic_crazy$transect_orientation == "EW")){ #looping against every ew observation
  
if(
  ( abs(picnic_crazy[i,'x'] - picnic_crazy[n,'x']) <= fuzz ) & 
    abs(picnic_crazy[i,'y'] - picnic_crazy[n,'y']) <= fuzz ){
    picnic_crazy[i, 'plant_id'] <- picnic_crazy[n, 'plant_id']
  }
  }
  
}
  temp_error <-  which(error == as.character(fuzz))  
   error[which(error == as.character(fuzz))] <- (nrow(filter(picnic_crazy, duplicated(plant_id))) / nrow(picnic_crossed))

   n_duplicated[which(n_duplicated == as.character(fuzz))] <- sum(duplicated(picnic_crazy$plant_id))
    
   n_actual[which(n_actual == as.character(fuzz))] <- n_distinct(picnic_crazy$plant_id)
   
   n_corrected[temp_error] <- mean( c(n_distinct(which(picnic_crazy$transect_orientation == "NS"))/error[temp_error],
                                       n_distinct(which(picnic_crazy$transect_orientation == "EW"))/error[temp_error]))
    
}
picnic_fuzz <- tibble(fuzziness, error, n_actual, n_duplicated, n_corrected)
stop <- Sys.time()
time <- stop - start
 
```

```{r}
pivot_longer(picnic_fuzz, cols = !fuzziness, names_to= "type", values_to= "count") %>% 
  group_by(type) %>% 
  ggplot( aes(fuzziness, count, color = type))+
  geom_line() +
  labs( x = "Fuzziness (m)")
```

